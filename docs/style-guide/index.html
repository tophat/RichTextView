<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Style Guide · Rich Text View</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Make sure to read [Apple&#x27;s API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Style Guide · Rich Text View"/><meta property="og:type" content="website"/><meta property="og:url" content="https://richtextview.com/"/><meta property="og:description" content="Make sure to read [Apple&#x27;s API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)."/><meta property="og:image" content="https://richtextview.com/img/rtv.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://richtextview.com/img/rtv.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-129741728-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/rtv.png" alt="Rich Text View"/><h2 class="headerTitleWithLogo">Rich Text View</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://github.com/tophat/RichTextView" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Getting Started</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing">Contributing</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/style-guide">Style Guide</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Style Guide</h1></header><article><div><span><p>Make sure to read <a href="https://swift.org/documentation/api-design-guidelines/">Apple's API Design Guidelines</a>.</p>
<p>Specifics from these guidelines + additional remarks are mentioned below.</p>
<p>This guide was last updated for Swift 4.2 on November 22nd, 2018.</p>
<h2><a class="anchor" aria-hidden="true" id="table-of-contents"></a><a href="#table-of-contents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Table Of Contents</h2>
<ul>
<li><a href="#swift-style-guide">Swift Style Guide</a>
<ul>
<li><a href="#1-code-formatting">1. Code Formatting</a></li>
<li><a href="#2-naming">2. Naming</a></li>
<li><a href="#3-coding-style">3. Coding Style</a>
<ul>
<li><a href="#31-general">3.1 General</a></li>
<li><a href="#32-access-modifiers">3.2 Access Modifiers</a></li>
<li><a href="#33-custom-operators">3.3 Custom Operators</a></li>
<li><a href="#34-switch-statements-and-enums">3.4 Switch Statements and <code>enum</code>s</a></li>
<li><a href="#35-optionals">3.5 Optionals</a></li>
<li><a href="#36-protocols">3.6 Protocols</a></li>
<li><a href="#37-properties">3.7 Properties</a></li>
<li><a href="#38-closures">3.8 Closures</a></li>
<li><a href="#39-arrays">3.9 Arrays</a></li>
<li><a href="#310-error-handling">3.10 Error Handling</a></li>
<li><a href="#311-using-guard-statements">3.11 Using <code>guard</code> Statements</a></li>
</ul></li>
<li><a href="#4-documentationcomments">4. Documentation/Comments</a>
<ul>
<li><a href="#41-documentation">4.1 Documentation</a></li>
<li><a href="#42-other-commenting-guidelines">4.2 Other Commenting Guidelines</a></li>
</ul></li>
</ul></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="1-code-formatting"></a><a href="#1-code-formatting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Code Formatting</h2>
<ul>
<li><strong>1.1</strong> Use 4 spaces for tabs.</li>
<li><strong>1.2</strong> Avoid uncomfortably long lines with a hard maximum of 160 characters per line (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Page guide at column: 160 is helpful for this)</li>
<li><strong>1.3</strong> Ensure that there is a newline at the end of every file.</li>
<li><strong>1.4</strong> Ensure that there is no trailing whitespace anywhere (Xcode-&gt;Preferences-&gt;Text Editing-&gt;Automatically trim trailing whitespace + Including whitespace-only lines).</li>
<li><strong>1.5</strong> Do not place opening braces on new lines - we use the <a href="https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS">1TBS style</a>.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> x == y {
            <span class="hljs-comment">/* ... */</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x == z {
            <span class="hljs-comment">/* ... */</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* ... */</span>
        }
    }

    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><strong>1.6</strong> When writing a type for a property, constant, variable, a key for a dictionary, a function argument, a protocol conformance, or a superclass, don't add a space before the colon.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// specifying type</span>
<span class="hljs-keyword">let</span> pirateViewController: <span class="hljs-type">PirateViewController</span>

<span class="hljs-comment">// dictionary syntax (note that we left-align as opposed to aligning colons)</span>
<span class="hljs-keyword">let</span> ninjaDictionary: [<span class="hljs-type">String</span>: <span class="hljs-type">AnyObject</span>] = [
    <span class="hljs-string">"fightLikeDairyFarmer"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"disgusting"</span>: <span class="hljs-literal">true</span>
]

<span class="hljs-comment">// declaring a function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span>&lt;T, U: SomeProtocol&gt;<span class="hljs-params">(firstArgument: U, secondArgument: T)</span></span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>.<span class="hljs-type">RelatedType</span> == <span class="hljs-type">U</span> {
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// calling a function</span>
someFunction(someArgument: <span class="hljs-string">"Kitten"</span>)

<span class="hljs-comment">// superclasses</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PirateViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// protocols</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">PirateViewController</span>: <span class="hljs-title">UITableViewDataSource</span> </span>{
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><strong>1.7</strong> In general, there should be a space following a comma.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">let</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<ul>
<li><strong>1.8</strong> There should be a space before and after a binary operator such as <code>+</code>, <code>==</code>, or <code>-&gt;</code>. There should also not be a space after a <code>(</code> and before a <code>)</code>.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">let</span> myValue = <span class="hljs-number">20</span> + (<span class="hljs-number">30</span> / <span class="hljs-number">2</span>) * <span class="hljs-number">3</span>
<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> == <span class="hljs-number">3</span> {
    <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"The universe is broken."</span>)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pancake</span><span class="hljs-params">(with syrup: Syrup)</span></span> -&gt; <span class="hljs-type">Pancake</span> {
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><strong>1.9</strong> We follow Xcode's recommended indentation style (i.e. your code should not change if CTRL-I is pressed). When declaring a function that spans multiple lines, prefer using that syntax to which Xcode, as of version 7.3, defaults.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// Xcode indentation for a function declaration that spans multiple lines</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunctionWithManyParameters</span><span class="hljs-params">(parameterOne: String,
                                  parameterTwo: String,
                                  parameterThree: String)</span></span> {
    <span class="hljs-comment">// Xcode indents to here for this kind of statement</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(parameterOne) \(parameterTwo) \(parameterThree)"</span>)
}

<span class="hljs-comment">// Xcode indentation for a multi-line `if` statement</span>
<span class="hljs-keyword">if</span> myFirstValue &gt; (mySecondValue + myThirdValue)
    &amp;&amp; myFourthValue == .someEnumValue {

    <span class="hljs-comment">// Xcode indents to here for this kind of statement</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, World!"</span>)
}
</code></pre>
<ul>
<li><strong>1.10</strong> When calling a function that has many parameters, put each argument on a separate line with a single extra indentation. Note the opening and closing parentheses on lines that are different from the parameters.</li>
</ul>
<pre><code class="hljs css language-swift">someFunctionWithManyArguments(
    firstArgument: <span class="hljs-string">"Hello, I am a string"</span>,
    secondArgument: resultFromSomeFunction(),
    thirdArgument: someOtherLocalProperty
)
</code></pre>
<ul>
<li><strong>1.11</strong> When dealing with an implicit array or dictionary large enough to warrant splitting it into multiple lines, treat the <code>[</code> and <code>]</code> as if they were braces in a method, <code>if</code> statement, etc. Closures in a method should be treated similarly.</li>
</ul>
<pre><code class="hljs css language-swift">someFunctionWithABunchOfArguments(
    someStringArgument: <span class="hljs-string">"hello I am a string"</span>,
    someArrayArgument: [
        <span class="hljs-string">"dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa"</span>,
        <span class="hljs-string">"string one is crazy - what is it thinking?"</span>
    ],
    someDictionaryArgument: [
        <span class="hljs-string">"dictionary key 1"</span>: <span class="hljs-string">"some value 1, but also some more text here"</span>,
        <span class="hljs-string">"dictionary key 2"</span>: <span class="hljs-string">"some value 2"</span>
    ],
    someClosure: { parameter1 <span class="hljs-keyword">in</span>
        <span class="hljs-built_in">print</span>(parameter1)
    })
</code></pre>
<ul>
<li><strong>1.12</strong> Prefer using local constants or other mitigation techniques to avoid multi-line predicates where possible.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">let</span> firstCondition = x == firstReallyReallyLongPredicateFunction()
<span class="hljs-keyword">let</span> secondCondition = y == secondReallyReallyLongPredicateFunction()
<span class="hljs-keyword">let</span> thirdCondition = z == thirdReallyReallyLongPredicateFunction()
<span class="hljs-keyword">if</span> firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition {
    <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">if</span> x == firstReallyReallyLongPredicateFunction()
    &amp;&amp; y == secondReallyReallyLongPredicateFunction()
    &amp;&amp; z == thirdReallyReallyLongPredicateFunction() {
    <span class="hljs-comment">// do something</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="2-naming"></a><a href="#2-naming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Naming</h2>
<ul>
<li><p><strong>2.1</strong> Use <code>PascalCase</code> for type names (e.g. <code>struct</code>, <code>enum</code>, <code>class</code>, <code>typedef</code>, <code>associatedtype</code>, etc.).</p></li>
<li><p><strong>2.2</strong> Use <code>camelCase</code> (initial lowercase letter) for function, method, property, constant, variable, argument names, enum cases, etc.).</p></li>
<li><p><strong>2.3</strong> When dealing with an acronym or other name that is usually written in all caps, actually use all caps in any names that use this in code. The exception is if this word is at the start of a name that needs to start with lowercase - in this case, use all lowercase for the acronym.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// "HTML" is at the start of a constant name, so we use lowercase "html"</span>
<span class="hljs-keyword">let</span> htmlBodyContent: <span class="hljs-type">String</span> = <span class="hljs-string">"&lt;p&gt;Hello, World!&lt;/p&gt;"</span>
<span class="hljs-comment">// Prefer using ID to Id</span>
<span class="hljs-keyword">let</span> profileID: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>
<span class="hljs-comment">// Prefer URLFinder to UrlFinder</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLFinder</span> </span>{
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><strong>2.4</strong> All constants other than singletons that are instance-independent should be <code>static</code>. All such <code>static</code> constants should be placed in a container <code>enum</code> type as per rule <strong>3.1.16</strong>. The naming of this container should be singular (e.g. <code>Constant</code> and not <code>Constants</code>) and it should be named such that it is relatively obvious that it is a constant container. If this is not obvious, you can add a <code>Constant</code> suffix to the name. You should use these containers to group constants that have similar or the same prefixes, suffixes and/or use cases.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassName</span> </span>{
    <span class="hljs-comment">// PREFERRED</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AccessibilityIdentifier</span> </span>{
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> pirateButton = <span class="hljs-string">"pirate_button"</span>
    }
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SillyMathConstant</span> </span>{
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> indianaPi = <span class="hljs-number">3</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">MyClassName</span>()

    <span class="hljs-comment">// NOT PREFERRED</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> kPirateButtonAccessibilityIdentifier = <span class="hljs-string">"pirate_button"</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SillyMath</span> </span>{
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> indianaPi = <span class="hljs-number">3</span>
    }
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>{
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">MyClassName</span>()
    }
}
</code></pre>
<ul>
<li><strong>2.5</strong> For generics and associated types, use a <code>PascalCase</code> word that describes the generic. If this word clashes with a protocol that it conforms to or a superclass that it subclasses, you can append a <code>Type</code> suffix to the associated type or generic name.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span>&lt;<span class="hljs-title">Model</span>&gt; </span>{ <span class="hljs-comment">/* ... */</span> }
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Modelable</span> </span>{
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Model</span>
}
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Sequence</span> </span>{
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">IteratorType</span>: <span class="hljs-type">Iterator</span>
}
</code></pre>
<ul>
<li><strong>2.6</strong> Names should be descriptive and unambiguous.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundAnimatingButton</span>: <span class="hljs-title">UIButton</span> </span>{ <span class="hljs-comment">/* ... */</span> }

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span>: <span class="hljs-title">UIButton</span> </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre>
<ul>
<li><strong>2.7</strong> Do not abbreviate, use shortened names, or single letter names.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundAnimatingButton</span>: <span class="hljs-title">UIButton</span> </span>{
    <span class="hljs-keyword">let</span> animationDuration: <span class="hljs-type">NSTimeInterval</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startAnimating</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> firstSubview = subviews.first
    }

}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundAnimating</span>: <span class="hljs-title">UIButton</span> </span>{
    <span class="hljs-keyword">let</span> aniDur: <span class="hljs-type">NSTimeInterval</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">srtAnmating</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> v = subviews.first
    }
}
</code></pre>
<ul>
<li><strong>2.8</strong> Include type information in constant or variable names when it is not obvious otherwise.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionTableViewCell</span>: <span class="hljs-title">UITableViewCell</span> </span>{
    <span class="hljs-keyword">let</span> personImageView: <span class="hljs-type">UIImageView</span>

    <span class="hljs-keyword">let</span> animationDuration: <span class="hljs-type">TimeInterval</span>

    <span class="hljs-comment">// it is ok not to include string in the ivar name here because it's obvious</span>
    <span class="hljs-comment">// that it's a string from the property name</span>
    <span class="hljs-keyword">let</span> firstName: <span class="hljs-type">String</span>

    <span class="hljs-comment">// though not preferred, it is OK to use `Controller` instead of `ViewController`</span>
    <span class="hljs-keyword">let</span> popupController: <span class="hljs-type">UIViewController</span>
    <span class="hljs-keyword">let</span> popupViewController: <span class="hljs-type">UIViewController</span>

    <span class="hljs-comment">// when working with a subclass of `UIViewController` such as a table view</span>
    <span class="hljs-comment">// controller, collection view controller, split view controller, etc.,</span>
    <span class="hljs-comment">// fully indicate the type in the name.</span>
    <span class="hljs-keyword">let</span> popupTableViewController: <span class="hljs-type">UITableViewController</span>

    <span class="hljs-comment">// when working with outlets, make sure to specify the outlet type in the</span>
    <span class="hljs-comment">// property name.</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> submitButton: <span class="hljs-type">UIButton!</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> emailTextField: <span class="hljs-type">UITextField!</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> nameLabel: <span class="hljs-type">UILabel!</span>

}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionTableViewCell</span>: <span class="hljs-title">UITableViewCell</span> </span>{
    <span class="hljs-comment">// this isn't a `UIImage`, so shouldn't be called image</span>
    <span class="hljs-comment">// use personImageView instead</span>
    <span class="hljs-keyword">let</span> personImage: <span class="hljs-type">UIImageView</span>

    <span class="hljs-comment">// this isn't a `String`, so it should be `textLabel`</span>
    <span class="hljs-keyword">let</span> text: <span class="hljs-type">UILabel</span>

    <span class="hljs-comment">// `animation` is not clearly a time interval</span>
    <span class="hljs-comment">// use `animationDuration` or `animationTimeInterval` instead</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">TimeInterval</span>

    <span class="hljs-comment">// this is not obviously a `String`</span>
    <span class="hljs-comment">// use `transitionText` or `transitionString` instead</span>
    <span class="hljs-keyword">let</span> transition: <span class="hljs-type">String</span>

    <span class="hljs-comment">// this is a view controller - not a view</span>
    <span class="hljs-keyword">let</span> popupView: <span class="hljs-type">UIViewController</span>

    <span class="hljs-comment">// as mentioned previously, we don't want to use abbreviations, so don't use</span>
    <span class="hljs-comment">// `VC` instead of `ViewController`</span>
    <span class="hljs-keyword">let</span> popupVC: <span class="hljs-type">UIViewController</span>

    <span class="hljs-comment">// even though this is still technically a `UIViewController`, this property</span>
    <span class="hljs-comment">// should indicate that we are working with a *Table* View Controller</span>
    <span class="hljs-keyword">let</span> popupViewController: <span class="hljs-type">UITableViewController</span>

    <span class="hljs-comment">// for the sake of consistency, we should put the type name at the end of the</span>
    <span class="hljs-comment">// property name and not at the start</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> btnSubmit: <span class="hljs-type">UIButton!</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> buttonSubmit: <span class="hljs-type">UIButton!</span>

    <span class="hljs-comment">// we should always have a type in the property name when dealing with outlets</span>
    <span class="hljs-comment">// for example, here, we should have `firstNameLabel` instead</span>
    <span class="hljs-meta">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> firstName: <span class="hljs-type">UILabel!</span>
}
</code></pre>
<ul>
<li><p><strong>2.9</strong> When naming function arguments, make sure that the function can be read easily to understand the purpose of each argument.</p></li>
<li><p><strong>2.10</strong> As per <a href="https://swift.org/documentation/api-design-guidelines/">Apple's API Design Guidelines</a>, a <code>protocol</code> should be named as nouns if they describe what something is doing (e.g. <code>Collection</code>) and using the suffixes <code>able</code>, <code>ible</code>, or <code>ing</code> if it describes a capability (e.g. <code>Equatable</code>, <code>ProgressReporting</code>). If neither of those options makes sense for your use case, you can add a <code>Protocol</code> suffix to the protocol's name as well. Some example <code>protocol</code>s are below.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// here, the name is a noun that describes what the protocol does</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TableViewSectionProvider</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rowHeight</span><span class="hljs-params">(at row: Int)</span></span> -&gt; <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> numberOfRows: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// here, the protocol is a capability, and we name it appropriately</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Loggable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logCurrentState</span><span class="hljs-params">()</span></span>
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// suppose we have an `InputTextView` class, but we also want a protocol</span>
<span class="hljs-comment">// to generalize some of the functionality - it might be appropriate to</span>
<span class="hljs-comment">// use the `Protocol` suffix here</span>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">InputTextViewProtocol</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendTrackingEvent</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inputText</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">String</span>
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3-coding-style"></a><a href="#3-coding-style" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Coding Style</h2>
<h3><a class="anchor" aria-hidden="true" id="31-general"></a><a href="#31-general" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.1 General</h3>
<ul>
<li><p><strong>3.1.1</strong> Prefer <code>let</code> to <code>var</code> whenever possible.</p></li>
<li><p><strong>3.1.2</strong> Prefer the composition of <code>map</code>, <code>filter</code>, <code>reduce</code>, etc. over iterating when transforming from one collection to another. Make sure to avoid using closures that have side effects when using these methods.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">let</span> stringOfInts = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].flatMap { <span class="hljs-type">String</span>($<span class="hljs-number">0</span>) }
<span class="hljs-comment">// ["1", "2", "3"]</span>

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">var</span> stringOfInts: [<span class="hljs-type">String</span>] = []
<span class="hljs-keyword">for</span> integer <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] {
    stringOfInts.append(<span class="hljs-type">String</span>(integer))
}

<span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">let</span> evenNumbers = [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span>].<span class="hljs-built_in">filter</span> { $<span class="hljs-number">0</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }
<span class="hljs-comment">// [4, 8, 16, 42]</span>

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">var</span> evenNumbers: [<span class="hljs-type">Int</span>] = []
<span class="hljs-keyword">for</span> integer <span class="hljs-keyword">in</span> [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span>] {
    <span class="hljs-keyword">if</span> integer % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
        evenNumbers.append(integer)
    }
}
</code></pre>
<ul>
<li><p><strong>3.1.3</strong> Prefer not declaring types for constants or variables if they can be inferred anyway.</p></li>
<li><p><strong>3.1.4</strong> If a function returns multiple values, prefer returning a tuple to using <code>inout</code> arguments (it’s best to use labeled tuples for clarity on what you’re returning if it is not otherwise obvious). If you use a certain tuple more than once, consider using a <code>typealias</code>. If you’re returning 3 or more items in a tuple, consider using a <code>struct</code> or <code>class</code> instead.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pirateName</span><span class="hljs-params">()</span></span> -&gt; (firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-string">"Guybrush"</span>, <span class="hljs-string">"Threepwood"</span>)
}

<span class="hljs-keyword">let</span> name = pirateName()
<span class="hljs-keyword">let</span> firstName = name.firstName
<span class="hljs-keyword">let</span> lastName = name.lastName
</code></pre>
<ul>
<li><p><strong>3.1.5</strong> Be wary of retain cycles when creating delegates/protocols for your classes; typically, these properties should be declared <code>weak</code>.</p></li>
<li><p><strong>3.1.6</strong> Be careful when calling <code>self</code> directly from an escaping closure as this can cause a retain cycle - use a <a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_163">capture list</a> when this might be the case:</p></li>
</ul>
<pre><code class="hljs css language-swift">myFunctionWithEscapingClosure() { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (error) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
    <span class="hljs-comment">// you can do this</span>

    <span class="hljs-keyword">self</span>?.doSomething()

    <span class="hljs-comment">// or you can do this</span>

    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> strongSelf = <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }

    strongSelf.doSomething()
}
</code></pre>
<ul>
<li><p><strong>3.1.7</strong> Don't use labeled breaks.</p></li>
<li><p><strong>3.1.8</strong> Don't place parentheses around control flow predicates.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">if</span> x == y {
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">if</span> (x == y) {
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><strong>3.1.9</strong> Avoid writing out an <code>enum</code> type where possible - use shorthand.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
imageView.setImageWithURL(url, type: .person)

<span class="hljs-comment">// NOT PREFERRED</span>
imageView.setImageWithURL(url, type: <span class="hljs-type">AsyncImageView</span>.<span class="hljs-type">Type</span>.person)
</code></pre>
<ul>
<li><strong>3.1.10</strong> Also use shorthand for class methods.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
imageView.backgroundColor = .white

<span class="hljs-comment">// NOT PREFERRED</span>
imageView.backgroundColor = <span class="hljs-type">UIColor</span>.white
</code></pre>
<ul>
<li><p><strong>3.1.11</strong> Prefer writing <code>self.</code></p></li>
<li><p><strong>3.1.12</strong> When writing methods, keep in mind whether the method is intended to be overridden or not. If not, mark it as <code>final</code>, though keep in mind that this will prevent the method from being overwritten for testing purposes. In general, <code>final</code> methods result in improved compilation times, so it is good to use this when applicable. Be particularly careful, however, when applying the <code>final</code> keyword in a library since it is non-trivial to change something to be non-<code>final</code> in a library as opposed to have changing something to be non-<code>final</code> in your local project.</p></li>
<li><p><strong>3.1.13</strong> When using a statement such as <code>else</code>, <code>catch</code>, etc. that follows a block, put this keyword on the same line as the block. Again, we are following the <a href="https://en.m.wikipedia.org/wiki/Indent_style#Variant:_1TBS">1TBS style</a> here. Example <code>if</code>/<code>else</code> and <code>do</code>/<code>catch</code> code is below.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">if</span> someBoolean {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// do something else</span>
}

<span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> fileContents = <span class="hljs-keyword">try</span> readFile(<span class="hljs-string">"filename.txt"</span>)
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_in">print</span>(error)
}
</code></pre>
<ul>
<li><p><strong>3.1.14</strong> Prefer <code>static</code> to <code>class</code> when declaring a function or property that is associated with a class as opposed to an instance of that class. Only use <code>class</code> if you specifically need the functionality of overriding that function or property in a subclass, though consider using a <code>protocol</code> to achieve this instead.</p></li>
<li><p><strong>3.1.15</strong> If you have a function that takes no arguments, has no side effects, and returns some object or value, prefer using a computed property instead.</p></li>
<li><p><strong>3.1.16</strong> For the purpose of namespacing a set of <code>static</code> functions and/or <code>static</code> properties, prefer using a caseless <code>enum</code> over a <code>class</code> or a <code>struct</code>. This way, you don't have to add a <code>private init() { }</code> to the container.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="32-access-modifiers"></a><a href="#32-access-modifiers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.2 Access Modifiers</h3>
<ul>
<li><strong>3.2.1</strong> Write the access modifier keyword first if it is needed.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> myPrivateNumber: <span class="hljs-type">Int</span>

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> myPrivateNumber: <span class="hljs-type">Int</span>
</code></pre>
<ul>
<li><strong>3.2.2</strong> The access modifier keyword should not be on a line by itself - keep it inline with what it is describing.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pirate</span> </span>{
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">open</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pirate</span> </span>{
    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<ul>
<li><p><strong>3.2.3</strong> In general, do not write the <code>internal</code> access modifier keyword since it is the default.</p></li>
<li><p><strong>3.2.4</strong> If a property needs to be accessed by unit tests, you will have to make it <code>internal</code> to use <code>@testable import ModuleName</code>. If a property <em>should</em> be private, but you declare it to be <code>internal</code> for the purposes of unit testing, make sure you add an appropriate bit of documentation commenting that explains this. You can make use of the <code>- warning:</code> markup syntax for clarity as shown below.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">/**
 This property defines the pirate's name.
 - warning: Not `private` for `@testable`.
 */</span>
<span class="hljs-keyword">let</span> pirateName = <span class="hljs-string">"LeChuck"</span>
</code></pre>
<ul>
<li><p><strong>3.2.5</strong> Prefer <code>private</code> to <code>fileprivate</code> where possible.</p></li>
<li><p><strong>3.2.6</strong> When choosing between <code>public</code> and <code>open</code>, prefer <code>open</code> if you intend for something to be subclassable outside of a given module and <code>public</code> otherwise. Note that anything <code>internal</code> and above can be subclassed in tests by using <code>@testable import</code>, so this shouldn't be a reason to use <code>open</code>. In general, lean towards being a bit more liberal with using <code>open</code> when it comes to libraries, but a bit more conservative when it comes to modules in a codebase such as an app where it is easy to change things in multiple modules simultaneously.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="33-custom-operators"></a><a href="#33-custom-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.3 Custom Operators</h3>
<p>Prefer creating named functions to custom operators.</p>
<p>If you want to introduce a custom operator, make sure that you have a <em>very</em> good reason why you want to introduce a new operator into global scope as opposed to using some other construct.</p>
<p>You can override existing operators to support new types (especially <code>==</code>). However, your new definitions must preserve the semantics of the operator. For example, <code>==</code> must always test equality and return a boolean.</p>
<h3><a class="anchor" aria-hidden="true" id="34-switch-statements-and-enums"></a><a href="#34-switch-statements-and-enums" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.4 Switch Statements and <code>enum</code>s</h3>
<ul>
<li><p><strong>3.4.1</strong> When using a switch statement that has a finite set of possibilities (<code>enum</code>), do <em>NOT</em> include a <code>default</code> case. Instead, place unused cases at the bottom and use the <code>break</code> keyword to prevent execution.</p></li>
<li><p><strong>3.4.2</strong> Since <code>switch</code> cases in Swift break by default, do not include the <code>break</code> keyword if it is not needed.</p></li>
<li><p><strong>3.4.3</strong> The <code>case</code> statements should line up with the <code>switch</code> statement itself as per default Swift standards.</p></li>
<li><p><strong>3.4.4</strong> When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. <code>case Hunger(hungerLevel: Int)</code> instead of <code>case Hunger(Int)</code>).</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Problem</span> </span>{
    <span class="hljs-keyword">case</span> attitude
    <span class="hljs-keyword">case</span> hair
    <span class="hljs-keyword">case</span> hunger(hungerLevel: <span class="hljs-type">Int</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleProblem</span><span class="hljs-params">(problem: Problem)</span></span> {
    <span class="hljs-keyword">switch</span> problem {
    <span class="hljs-keyword">case</span> .attitude:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"At least I don't have a hair problem."</span>)
    <span class="hljs-keyword">case</span> .hair:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Your barber didn't know when to stop."</span>)
    <span class="hljs-keyword">case</span> .hunger(<span class="hljs-keyword">let</span> hungerLevel):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"The hunger level is \(hungerLevel)."</span>)
    }
}
</code></pre>
<ul>
<li><p><strong>3.4.5</strong> Prefer lists of possibilities (e.g. <code>case 1, 2, 3:</code>) to using the <code>fallthrough</code> keyword where possible).</p></li>
<li><p><strong>3.4.6</strong> If you have a default case that shouldn't be reached, preferably throw an error (or handle it some other similar way such as asserting).</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleDigit</span><span class="hljs-params">(<span class="hljs-number">_</span> digit: Int)</span></span> <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">switch</span> digit {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Yes, \(digit) is a digit!"</span>)
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-type">Error</span>(message: <span class="hljs-string">"The given number was not a digit."</span>)
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="35-optionals"></a><a href="#35-optionals" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.5 Optionals</h3>
<ul>
<li><p><strong>3.5.1</strong> The only time you should be using implicitly unwrapped optionals is with <code>@IBOutlet</code>s. In every other case, it is better to use a non-optional or regular optional property. Yes, there are cases in which you can probably &quot;guarantee&quot; that the property will never be <code>nil</code> when used, but it is better to be safe and consistent. Similarly, don't use force unwraps.</p></li>
<li><p><strong>3.5.2</strong> Don't use <code>as!</code> or <code>try!</code>.</p></li>
<li><p><strong>3.5.3</strong> If you don't plan on actually using the value stored in an optional, but need to determine whether or not this value is <code>nil</code>, explicitly check this value against <code>nil</code> as opposed to using <code>if let</code> syntax.</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERERED</span>
<span class="hljs-keyword">if</span> someOptional != <span class="hljs-literal">nil</span> {
    <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = someOptional {
    <span class="hljs-comment">// do something</span>
}
</code></pre>
<ul>
<li><strong>3.5.4</strong> Don't use <code>unowned</code>. You can think of <code>unowned</code> as somewhat of an equivalent of a <code>weak</code> property that is implicitly unwrapped (though <code>unowned</code> has slight performance improvements on account of completely ignoring reference counting). Since we don't ever want to have implicit unwraps, we similarly don't want <code>unowned</code> properties.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> parentViewController: <span class="hljs-type">UIViewController?</span>

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> parentViewController: <span class="hljs-type">UIViewController!</span>
<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">var</span> parentViewController: <span class="hljs-type">UIViewController</span>
</code></pre>
<ul>
<li><strong>3.5.5</strong> When unwrapping optionals, use the same name for the unwrapped constant or variable where appropriate.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> myValue = myValue <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
</code></pre>
<ul>
<li><strong>3.5.5</strong> Prefer using <code>guard let</code> syntax over <code>if let</code> where possible to avoid nesting code.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> myValue = myValue <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
<span class="hljs-comment">// do something</span>

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> myValue = myValue {
    <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="36-protocols"></a><a href="#36-protocols" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.6 Protocols</h3>
<p>When implementing protocols, organize your code by using <code>// MARK:</code> comments to separate your protocol implementation from the rest of your code</p>
<h3><a class="anchor" aria-hidden="true" id="37-properties"></a><a href="#37-properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.7 Properties</h3>
<ul>
<li><strong>3.7.1</strong> If making a read-only, computed property, provide the getter without the <code>get {}</code> around it.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">var</span> computedProperty: <span class="hljs-type">String</span> {
    <span class="hljs-keyword">if</span> someBool {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"I'm a mighty pirate!"</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"I'm selling these fine leather jackets."</span>
}
</code></pre>
<ul>
<li><strong>3.7.2</strong> When using <code>get {}</code>, <code>set {}</code>, <code>willSet</code>, and <code>didSet</code>, indent these blocks.</li>
<li><strong>3.7.3</strong> Though you can create a custom name for the new or old value for <code>willSet</code>/<code>didSet</code> and <code>set</code>, use the standard <code>newValue</code>/<code>oldValue</code> identifiers that are provided by default.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">var</span> storedProperty: <span class="hljs-type">String</span> = <span class="hljs-string">"I'm selling these fine leather jackets."</span> {
    <span class="hljs-keyword">willSet</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"will set to \(newValue)"</span>)
    }
    <span class="hljs-keyword">didSet</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"did set from \(oldValue) to \(storedProperty)"</span>)
    }
}

<span class="hljs-keyword">var</span> computedProperty: <span class="hljs-type">String</span>  {
    <span class="hljs-keyword">get</span> {
        <span class="hljs-keyword">if</span> someBool {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"I'm a mighty pirate!"</span>
        }
        <span class="hljs-keyword">return</span> storedProperty
    }
    <span class="hljs-keyword">set</span> {
        storedProperty = newValue
    }
}
</code></pre>
<ul>
<li><strong>3.7.4</strong> You can declare a singleton property as follows:</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PirateManager</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">PirateManager</span>()

    <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="38-closures"></a><a href="#38-closures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.8 Closures</h3>
<ul>
<li><strong>3.8.1</strong> If the types of the parameters are obvious, it is OK to omit the type name, but being explicit is also OK. Sometimes readability is enhanced by adding clarifying detail and sometimes by taking repetitive parts away - use your best judgment and be consistent.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// omitting the type</span>
doSomethingWithClosure() { response <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(response)
}

<span class="hljs-comment">// explicit type</span>
doSomethingWithClosure() { response: <span class="hljs-type">NSURLResponse</span> <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(response)
}

<span class="hljs-comment">// using shorthand in a map statement</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].flatMap { <span class="hljs-type">String</span>($<span class="hljs-number">0</span>) }
</code></pre>
<ul>
<li><strong>3.8.2</strong> If specifying a closure as a type, you don’t need to wrap it in parentheses unless it is required (e.g. if the type is optional or the closure is within another closure). Always wrap the arguments in the closure in a set of parentheses - use <code>()</code> to indicate no arguments and use <code>Void</code> to indicate that nothing is returned.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">let</span> completionBlock: (<span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Void</span> = { (success) <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Success? \(success)"</span>)
}

<span class="hljs-keyword">let</span> completionBlock: () -&gt; <span class="hljs-type">Void</span> = {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Completed!"</span>)
}

<span class="hljs-keyword">let</span> completionBlock: (() -&gt; <span class="hljs-type">Void</span>)? = <span class="hljs-literal">nil</span>
</code></pre>
<ul>
<li><p><strong>3.8.3</strong> Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters).</p></li>
<li><p><strong>3.8.4</strong> Use trailing closure syntax unless the meaning of the closure is not obvious without the parameter name (an example of this could be if a method has parameters for success and failure closures).</p></li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// trailing closure</span>
doSomething(<span class="hljs-number">1.0</span>) { (parameter1) <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Parameter 1 is \(parameter1)"</span>)
}

<span class="hljs-comment">// no trailing closure</span>
doSomething(<span class="hljs-number">1.0</span>, success: { (parameter1) <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Success with \(parameter1)"</span>)
}, failure: { (parameter1) <span class="hljs-keyword">in</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Failure with \(parameter1)"</span>)
})
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="39-arrays"></a><a href="#39-arrays" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.9 Arrays</h3>
<ul>
<li><p><strong>3.9.1</strong> In general, avoid accessing an array directly with subscripts. When possible, use accessors such as <code>.first</code> or <code>.last</code>, which are optional and won’t crash. Prefer using a <code>for item in items</code> syntax when possible as opposed to something like <code>for i in 0 ..&lt; items.count</code>. If you need to access an array subscript directly, make sure to do proper bounds checking. You can use <code>for (index, value) in items.enumerated()</code> to get both the index and the value.</p></li>
<li><p><strong>3.9.2</strong> Never use the <code>+=</code> or <code>+</code> operator to append/concatenate to arrays. Instead, use <code>.append()</code> or <code>.append(contentsOf:)</code> as these are far more performant (at least with respect to compilation) in Swift's current state. If you are declaring an array that is based on other arrays and want to keep it immutable, instead of <code>let myNewArray = arr1 + arr2</code>, use <code>let myNewArray = [arr1, arr2].joined()</code>.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="310-error-handling"></a><a href="#310-error-handling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.10 Error Handling</h3>
<p>Suppose a function <code>myFunction</code> is supposed to return a <code>String</code>, however, at some point it can run into an error. A common approach is to have this function return an optional <code>String?</code> where we return <code>nil</code> if something went wrong.</p>
<p>Example:</p>
<pre><code class="hljs css language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(named filename: String)</span></span> -&gt; <span class="hljs-type">String?</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> file = openFile(named: filename) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }

    <span class="hljs-keyword">let</span> fileContents = file.read()
    file.close()
    <span class="hljs-keyword">return</span> fileContents
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSomeFile</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> filename = <span class="hljs-string">"somefile.txt"</span>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> fileContents = readFile(named: filename) <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Unable to open file \(filename)."</span>)
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-built_in">print</span>(fileContents)
}
</code></pre>
<p>Instead, we should be using Swift's <code>try</code>/<code>catch</code> behavior when it is appropriate to know the reason for the failure.</p>
<p>You can use a <code>struct</code> such as the following:</p>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Error</span>: <span class="hljs-title">Swift</span>.<span class="hljs-title">Error</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> file: <span class="hljs-type">StaticString</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> function: <span class="hljs-type">StaticString</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> line: <span class="hljs-type">UInt</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> message: <span class="hljs-type">String</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(message: <span class="hljs-type">String</span>, file: <span class="hljs-type">StaticString</span> = #file, function: <span class="hljs-type">StaticString</span> = #function, line: <span class="hljs-type">UInt</span> = #line) {
        <span class="hljs-keyword">self</span>.file = file
        <span class="hljs-keyword">self</span>.function = function
        <span class="hljs-keyword">self</span>.line = line
        <span class="hljs-keyword">self</span>.message = message
    }
}
</code></pre>
<p>Example usage:</p>
<pre><code class="hljs css language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(named filename: String)</span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">String</span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> file = openFile(named: filename) <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-type">Error</span>(message: <span class="hljs-string">"Unable to open file named \(filename)."</span>)
    }

    <span class="hljs-keyword">let</span> fileContents = file.read()
    file.close()
    <span class="hljs-keyword">return</span> fileContents
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSomeFile</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">let</span> fileContents = <span class="hljs-keyword">try</span> readFile(named: filename)
        <span class="hljs-built_in">print</span>(fileContents)
    } <span class="hljs-keyword">catch</span> {
        <span class="hljs-built_in">print</span>(error)
    }
}
</code></pre>
<p>There are some exceptions in which it does make sense to use an optional as opposed to error handling. When the result should <em>semantically</em> potentially be <code>nil</code> as opposed to something going wrong while retrieving the result, it makes sense to return an optional instead of using error handling.</p>
<p>In general, if a method can &quot;fail&quot;, and the reason for the failure is not immediately obvious if using an optional return type, it probably makes sense for the method to throw an error.</p>
<h3><a class="anchor" aria-hidden="true" id="311-using-guard-statements"></a><a href="#311-using-guard-statements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3.11 Using <code>guard</code> Statements</h3>
<ul>
<li><strong>3.11.1</strong> In general, we prefer to use an &quot;early return&quot; strategy where applicable as opposed to nesting code in <code>if</code> statements. Using <code>guard</code> statements for this use-case is often helpful and can improve the readability of the code.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eatDoughnut</span><span class="hljs-params">(at index: Int)</span></span> {
    <span class="hljs-keyword">guard</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; doughnuts.<span class="hljs-built_in">count</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// return early because the index is out of bounds</span>
        <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">let</span> doughnut = doughnuts[index]
    eat(doughnut)
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eatDoughnut</span><span class="hljs-params">(at index: Int)</span></span> {
    <span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; doughnuts.<span class="hljs-built_in">count</span> {
        <span class="hljs-keyword">let</span> doughnut = doughnuts[index]
        eat(doughnut)
    }
}
</code></pre>
<ul>
<li><strong>3.11.2</strong> When unwrapping optionals, prefer <code>guard</code> statements as opposed to <code>if</code> statements to decrease the amount of nested indentation in your code.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> monkeyIsland = monkeyIsland <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
bookVacation(on: monkeyIsland)
bragAboutVacation(at: monkeyIsland)

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> monkeyIsland = monkeyIsland {
    bookVacation(on: monkeyIsland)
    bragAboutVacation(at: monkeyIsland)
}

<span class="hljs-comment">// EVEN LESS PREFERRED</span>
<span class="hljs-keyword">if</span> monkeyIsland == <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span>
}
bookVacation(on: monkeyIsland!)
bragAboutVacation(at: monkeyIsland!)
</code></pre>
<ul>
<li><strong>3.11.3</strong> When deciding between using an <code>if</code> statement or a <code>guard</code> statement when unwrapping optionals is <em>not</em> involved, the most important thing to keep in mind is the readability of the code. There are many possible cases here, such as depending on two different booleans, a complicated logical statement involving multiple comparisons, etc., so in general, use your best judgement to write code that is readable and consistent. If you are unsure whether <code>guard</code> or <code>if</code> is more readable or they seem equally readable, prefer using <code>guard</code>.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// an `if` statement is readable here</span>
<span class="hljs-keyword">if</span> operationFailed {
    <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// a `guard` statement is readable here</span>
<span class="hljs-keyword">guard</span> isSuccessful <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// double negative logic like this can get hard to read - i.e. don't do this</span>
<span class="hljs-keyword">guard</span> !operationFailed <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}
</code></pre>
<ul>
<li><strong>3.11.4</strong> If choosing between two different states, it makes more sense to use an <code>if</code> statement as opposed to a <code>guard</code> statement.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">if</span> isFriendly {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, nice to meet you!"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"You have the manners of a beggar."</span>)
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">guard</span> isFriendly <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"You have the manners of a beggar."</span>)
    <span class="hljs-keyword">return</span>
}

<span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello, nice to meet you!"</span>)
</code></pre>
<ul>
<li><strong>3.11.5</strong> You should also use <code>guard</code> only if a failure should result in exiting the current context. Below is an example in which it makes more sense to use two <code>if</code> statements instead of using two <code>guard</code>s - we have two unrelated conditions that should not block one another.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> monkeyIsland = monkeyIsland {
    bookVacation(onIsland: monkeyIsland)
}

<span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> woodchuck = woodchuck, canChuckWood(woodchuck) {
    woodchuck.chuckWood()
}
</code></pre>
<ul>
<li><strong>3.11.6</strong> Often, we can run into a situation in which we need to unwrap multiple optionals using <code>guard</code> statements. In general, combine unwraps into a single <code>guard</code> statement if handling the failure of each unwrap is identical (e.g. just a <code>return</code>, <code>break</code>, <code>continue</code>, <code>throw</code>, or some other <code>@noescape</code>).</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// combined because we just return</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingOne = thingOne,
    <span class="hljs-keyword">let</span> thingTwo = thingTwo,
    <span class="hljs-keyword">let</span> thingThree = thingThree <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// separate statements because we handle a specific error in each case</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingOne = thingOne <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-type">Error</span>(message: <span class="hljs-string">"Unwrapping thingOne failed."</span>)
}

<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingTwo = thingTwo <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-type">Error</span>(message: <span class="hljs-string">"Unwrapping thingTwo failed."</span>)
}

<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingThree = thingThree <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-type">Error</span>(message: <span class="hljs-string">"Unwrapping thingThree failed."</span>)
}
</code></pre>
<ul>
<li><strong>3.11.7</strong> Don’t use one-liners for <code>guard</code> statements.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-comment">// PREFERRED</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingOne = thingOne <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// NOT PREFERRED</span>
<span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> thingOne = thingOne <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4-documentationcomments"></a><a href="#4-documentationcomments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. Documentation/Comments</h2>
<h3><a class="anchor" aria-hidden="true" id="41-documentation"></a><a href="#41-documentation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.1 Documentation</h3>
<p>In general, documentation and comments should be used as a last resort. If you encounter a portion/block of code that needs commenting consider refactoring the code to make it clearer first.</p>
<h3><a class="anchor" aria-hidden="true" id="42-other-commenting-guidelines"></a><a href="#42-other-commenting-guidelines" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4.2 Other Commenting Guidelines</h3>
<ul>
<li><strong>4.2.1</strong> Always leave a space after <code>//</code>.</li>
<li><strong>4.2.2</strong> Always leave comments on their own line.</li>
<li><strong>4.2.3</strong> When using <code>// MARK: - whatever</code>, leave a newline after the comment.</li>
</ul>
<pre><code class="hljs css language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pirate</span> </span>{

    <span class="hljs-comment">// MARK: - instance properties</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> pirateName: <span class="hljs-type">String</span>

    <span class="hljs-comment">// MARK: - initialization</span>

    <span class="hljs-keyword">init</span>() {
        <span class="hljs-comment">/* ... */</span>
    }

}
</code></pre>
</span></div></article></div><div class="docLastUpdate"><em>Last updated by Ahmed Elkady</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/contributing"><span class="arrow-prev">← </span><span>Contributing</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#table-of-contents">Table Of Contents</a></li><li><a href="#1-code-formatting">1. Code Formatting</a></li><li><a href="#2-naming">2. Naming</a></li><li><a href="#3-coding-style">3. Coding Style</a><ul class="toc-headings"><li><a href="#31-general">3.1 General</a></li><li><a href="#32-access-modifiers">3.2 Access Modifiers</a></li><li><a href="#33-custom-operators">3.3 Custom Operators</a></li><li><a href="#34-switch-statements-and-enums">3.4 Switch Statements and <code>enum</code>s</a></li><li><a href="#35-optionals">3.5 Optionals</a></li><li><a href="#36-protocols">3.6 Protocols</a></li><li><a href="#37-properties">3.7 Properties</a></li><li><a href="#38-closures">3.8 Closures</a></li><li><a href="#39-arrays">3.9 Arrays</a></li><li><a href="#310-error-handling">3.10 Error Handling</a></li><li><a href="#311-using-guard-statements">3.11 Using <code>guard</code> Statements</a></li></ul></li><li><a href="#4-documentationcomments">4. Documentation/Comments</a><ul class="toc-headings"><li><a href="#41-documentation">4.1 Documentation</a></li><li><a href="#42-other-commenting-guidelines">4.2 Other Commenting Guidelines</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="footer"><div class="footer-icon"><a href="/" class="nav-home"><img src="/img/rtv.png" alt="Rich Text View" width="58" height="58"/></a></div><div class="footer-github"><a href="https://github.com/tophat/RichTextView">GitHub</a><a class="github-button" href="https://github.com/tophat/RichTextView" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Top Hat Open Source</section></footer></div></body></html>